#!/usr/bin/env php
<?php

# (C) Copyright Peter Koppstein (peak@princeton.edu)
# License: Apache License 2.0 (see website)
# Website: https://github.com/pkoppstein/jm
# With special thanks to https://github.com/halaxa, the creator of "JSON Machine".

$jmVersion="0.0.8 of 2022.10.15";

# NEWS:
# 0.0.8 allow process file descriptors

$bn=basename(__FILE__);
$home = exec( 'echo ~' ) ;

$dirs = array(
  $home.'/vendor/autoload.php',
  __DIR__.'/vendor/autoload.php',
  dirname(__DIR__).'/vendor/autoload.php'
  );

$autoload = '';	
foreach ($dirs as &$value) {
  if (is_file($value)) { $autoload = $value; break; }
}   

if ($autoload == '') {
  $autoload = $home . '/github/json-machine/src/autoloader.php';
  if (is_file($autoload)) {
     spl_autoload_register(require $autoload);
  } else {
      fwrite(STDERR, __FILE__ .
       ': composer autoloader missing. Try running "composer require halaxa/json-machine".'."\n");
    exit(1);
  }
} else {
  require_once $autoload;
}  

use JsonMachine\Items;
use JsonMachine\JsonDecoder\PassThruDecoder;

function usage() {
  global $bn;
echo <<<END
Usage: {$bn} [ OPTIONS ]  [ FILEPATH ... ]
or:    {$bn} [-h | --help]
where JSONPOINTER defaults to '' and FILEPATH defaults to stdin, and the other options are:
     -s
     --array
     --bigint_as_string | --recode
     --count | --limit=LIMIT
     --pointer=JSONPOINTER
     --version
\n
END;
}

function help() {
  global $bn, $jmVersion;  
echo <<<END
The -h option gives a usage summary, and --help gives more detailed help.
The -s option directs that JSON objects be streamed as singleton (single-key) objects.
The long options are described below.

One of the main uses of {$bn} is to stream losslessly a JSON array or
JSON object that occurs at the top-level or within a very large JSON structure.

In this document, streaming a JSON array is to be understood as
producing a stream of the top-level items in the array (one line per
item); similarly, streaming a JSON object means producing a stream of
the top-level values or of the key-value singleton objects if the -s
option is specified.  Streaming other JSON values simply means
printing them, though the way in which JSON numbers are printed
depends on the mutually exclusive `--recode` and `--bigint_as_string` options:

  * --recode causes all JSON numbers to be presented as PHP numeric values
      with the potential loss of information this implies;
  * --bigint_as_string causes JSON "big integers" to be converted to
      strings to avoid loss of information, but other numbers will be
      converted to PHP numeric values;
  * if neither of these options is specified, the literal form of numbers is preserved.
  
If no JSON Pointer is specified, or if it is specified as the empty
string (""), then the top-level entity is streamed.

If a JSON Pointer is specified, then all the corresponding entities
are streamed successively, as illustrated in Example (8) below.

The --array option causes the streamed items to be presented as a JSON array.

The --count option specifies that for each input source or file, the
count of the number of lines that would be emitted by this script when
streaming should be printed instead; for each file, the count is
preceded by the file name.

The --limit option limits the total number of lines that are emitted
by this script per input file, when streaming.


Examples:
(1) jm <<< '[1,"2", {"a": 4}, [5.0000000000000000000000000006]]'
yields:

1
"2"
{"a":4}
[5.0000000000000000000000000006]

(2) jm <<< '{"a": 1, "b": [2,3]}'
yields

1
[2,3]

(3) jm -s <<< '{"a": 1, "b": [2,3]}'
yields

{"a": 1}
{"b": [2,3]}

(4) jm --pointer "/results" <<< '{"results": {"a": 1, "b": [2,3]}}'
yields the same stream as (2) above.

(5) jm --bigint_as_string <<< '[10000000000000000000002, 3.0000000000000000000004]'
yields

"10000000000000000000002"
3

(6) jm --array <<< '{"a": 1, "b": [2,3]}'
yields

[
1,
[2,3]
]

(7) jm --recode <(echo '[1.000000000000000001,20000000000000000003]')
yields

1
2.0e+19

(8) jm --pointer "/-" <<< '[1,[2,3]]'
yields

1
2
3

Note that in the last example, the JSON Pointer "/-" points in turn to
the items in the top-level array (i.e. 1 and then [2,3]), and that
streaming 1 produces 1, and streaming [2,3] produces 2 and then 3.

{$bn} is based on JSON Machine. For further details, see documentation on:

* "JSON Machine" e.g. https://github.com/halaxa/json-machine
* "JSON Pointer" e.g. https://www.rfc-editor.org/rfc/rfc6901#section-5

This is version {$jmVersion} of {$bn}.
\n
END;  
  exit(0);
}

$options = getopt("hs", ['debug', 'help', 'array', 'bigint_as_string', 'count', 'limit:', 'pointer:', 'recode', 'version'], $rest_index);

if (isset($options['help']))  { usage(); help(); exit(0); }
if (isset($options['h']))     { usage(); exit(0); }

if (isset($options['version'])) {
  print "$bn version ${jmVersion}\n";
  exit(0);
}

$singleton_option = isset($options['s']);
$limit_option = isset($options['limit']) ? $options['limit'] : false;
$count_option = isset($options['count']);
$recode_option = isset($options['recode']);
$bigint_option = isset($options['bigint_as_string']);
$array_option = isset($options['array']);
$suffix = isset($options['array']) ? ",\n" : "\n";

# Disallow: --bigint_as_string --recode
if ($recode_option && $bigint_option) {
      fwrite(STDERR, __FILE__ .
       ": at most one of the --recode and --bigint_as_string options may be specified.\n");
  exit(2);
}
# Disallow: --count --limit
if ($count_option && $limit_option) {
      fwrite(STDERR, __FILE__ .
       ": at most one of the --count and --limit options may be specified.\n");
  exit(2);
}

$pointer_options = isset($options['pointer']) ? ["pointer" => $options['pointer']] : [];

# By default, use the PassThruDecoder
if (! $recode_option) {$pointer_options += ['decoder' => new PassThruDecoder ]; }


## Debugging info:
if (isset($options['debug'])) {
   if ($recode_option) { print "NOTE: --recode option was specified\n"; }
   if ($bigint_option) { print "NOTE: --bigint_as_integer was specified\n"; }
   if ($limit_option) { print "NOTE: --limit={$limit_option} was specified\n"; }   
   if (isset($options['pointer'])) {
     print "Note: JSONPOINTER is: " . $options['pointer'] . "\n";
   }
}

# Down the recoding rabbit hole:
function tweak($value) {
  global $bigint_option;
  global $recode_option;
  # var_dump($value);
  if ($recode_option) { return json_encode($value); }
  if ($bigint_option) { return json_encode(json_decode($value, flags: JSON_BIGINT_AS_STRING)); }
  return $value; 
}

function process_objects($filepath, $options) {
  global $limit_option;
  global $count_option;
  global $array_option;
  global $suffix;
  $preface = ($filepath == "php://stdin") ? "" : $filepath. ": ";
  $i=0;
  $iterator = Items::fromFile( $filepath, $options);
  if ($count_option) {
    foreach ($iterator as $key => $value) {  $i++; }
    print $preface . $i ."\n";
    return;
  }

  if ($array_option) { print "[\n"; }
  foreach ($iterator as $key => $value) {
     if (gettype($key) == "integer") {
        if ($i > 0 ) { print $suffix; }
	print tweak($key);
     } else {
        if ($i > 0 ) { print $suffix; }
        print '{'. $key . ': ' . tweak($value) . "}" ;
     }
     $i++;
     if ($limit_option && ($i >= $limit_option)) {break;}
  }
  if ($array_option) { print "\n]\n"; } else {print "\n";}
}

function process($filepath, $options, $singleton_option) {
  global $limit_option;
  global $count_option;
  global $array_option;
  global $suffix;

  if ($singleton_option) { process_objects($filepath, $options); }
  else {
    $preface = ($filepath == "php://stdin") ? "" : $filepath. ": ";
    $i=0;
    $iterator = Items::fromFile( $filepath, $options);
    if ($count_option) {
      foreach ($iterator as $key => $value) {  $i++; }
      print $preface . $i . "\n";
      return;
    }

    if ($array_option) { print "[\n"; }
    foreach ($iterator as $row) {
       if ($i > 0) { echo $suffix; }
       echo tweak($row);
       $i++;
       if ($limit_option && ($i >= $limit_option)) {break;}
    }
    if ($array_option) { print "\n]\n"; } else {print "\n";}
  }
}

$pos_args = array_slice($argv, $rest_index);

$argx = count($pos_args);

if ($argx == 0) { process('php://stdin', $pointer_options, $singleton_option); exit(0); }

# Interpret the remaining arguments as filepaths or process file descriptors (/dev/fd/...) if possible.
foreach( $pos_args as &$filepath ) {
  if (preg_match('!^/dev/fd/[0-9]*$!', $filepath)) {
    if (file_exists($filepath)) { continue; }
    else {
      fwrite(STDERR, __FILE__ . ': specified process file descriptor not found: ' . $filepath . "\n");
      exit(1);
    }   
  }
  if (! is_file($filepath)) {
    fwrite(STDERR, __FILE__ . ': specified file not found: ' . $filepath . "\n");
    exit(1);
  }
}

foreach( $pos_args as &$filepath ) {
  process( $filepath, $pointer_options, $singleton_option );
}
